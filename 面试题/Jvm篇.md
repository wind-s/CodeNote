jvm篇

    1.性能调优过吗？
    2.垃圾回收机制算法
    3.加载器
        1.虚拟机自带加载器
        启动类加载器（bootstrap），
        扩展类加载器(extension)，
        应用程序类加载器（appclassloader 也叫系统加载器，加载当前应用的classpath的所有类）
        2.用户自定义加载器
    4.双亲委派模型
        就是加载类的时候，一直溯源到最原始的加载器，看看有没有存在的类，有就加载，没有就会退
    5.沙箱机制
        就是防止用户写的代码，对原有代码的修改，比如自己新建一个java.lang.String，肯定找到的是原系统的那个string.
    
    6.jvm运行内存的分类：
    1.堆
        java内存最大的一块，所有对象的实例，数组都存在在这里，gc回收的地方  线程共享
    2.虚拟机栈
        存放基本数据类型，对象引用，方法出口等                           线程私有
    3.方法区
        存放着已被加载的类信息，常量，静态变量，永久代的一些信息，
        编译器编译后的代码数据
        回收目标是常量池，和类型卸载                                    线程共享
    4.本地方法栈
        和虚拟机栈一样，只不过他服务于native方法                         线程私有
    5.程序计数器
        当前线程执行的行号指示器，用于记录正在执行的虚拟机字节指令地址       线程私有
    
    7.Java内存堆和栈区别？
    1.栈内存用来存储基本类型的变量和对象的引用变量。
      堆内存用来存储Java中的对象，无论是成员变量，局部变量，还是类变量，它们指向的对象都存储在堆内存中。
    2.栈内存归属于单个线程，其存储的变量只能在其所属线程中可见，即栈内存可以理解成线程的私有内存。
      堆内存中的对象对所有线程可见。堆内存中的对象可以被所有线程访问。
    3.栈内存没有可用的空间存储方法调用和局部变量，JVM会抛出java.lang.StackOverFlowError。
      堆内存没有可用的空间存储生成的对象，JVM会抛出java.lang.OutOfMemoryError。
    4.栈的内存要远远小于堆内存。
        如果你使用递归的话，那么你的栈很快就会充满，-Xss选项设置栈内存的大小。-Xms选项可以设置堆的开始时的大小
    
    8.Java四引用？
    1.强引用
        强引用是使用最普遍的引用。如果一个对象具有强引用，那垃圾回收器绝不会回收它。
        当内存空间不足，Java虚拟机宁愿抛出OutOfMemoryError错误，
        使程序异常终止，也不会靠随意回收具有强引用的对象来解决内存不足的问题
    2.软引用
        如果内存空间不足了，就会回收这些对象的内存。只要垃圾回收器没有回收它，
        软引用可以和一个引用队列（ReferenceQueue）联合使用，
        如果软引用所引用的对象被垃圾回收器回收，Java虚拟机就会把这个软引用加入到与之关联的引用队列中。
    3.弱引用
        弱引用与软引用的区别在于：只具有弱引用的对象拥有更短暂的生命周期。
        在垃圾回收器线程扫描它所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，
        不管当前内存空间足够与否，都会回收它的内存。
        弱引用可以和一个引用队列（ReferenceQueue）联合使用，如果弱引用所引用的对象被垃圾回收，Java虚拟机就会把这个弱引用加入到与之关联的引用队列中
    4.虚引用
        虚引用在任何时候都可能被垃圾回收器回收，主要用来跟踪对象被垃圾回收器回收的活动，
        被回收时会收到一个系统通知。虚引用与软引用和弱引用的一个区别在于：虚引用必须和引用队列 （ReferenceQueue）联合使用
        。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之关联的引用队列中。
    
    9.GC回收机制？
    1.Java中对象是采用new或者反射的方法创建的，这些对象的创建都是在堆（Heap）中分配的，
        所有对象的回收都是由Java虚拟机通过垃圾回收机制完成的。
    2.GC为了能够正确释放对象，会监控每个对象的运行状况，对他们的申请、引用、被引用、赋值等状况进行监控
        Java程序员不用担心内存管理，因为垃圾收集器会自动进行管理。
    
    10.GC标记对象的死活？
    1.引用计数法：
        给对象添加一个引用计数器,没当被引用的时候,计数器的值就加一。
        引用失效的时候减一,当计数器的值为 0 的时候就表示改对象可以被 GC 回收了，弊端:A->B,B->A,那么 AB 将永远不会被回收了。也就是引用有环的情况      
    2.根搜索算法(可达性算法)：
        通过一个叫 GC Roots 的对象作为起点,从这些结点开始向下搜索,搜索所走过的路径称为引用链, 当一个对象没有与任何的引用链相连的时候则该对象就可以被回收。
    
        可作为GC Roots的对象包括以下几种：
            1.虚拟机栈（栈帧中的本地变量表）中的引用的对象。
            2.方法区中的类静态属性引用的对象
            3.方法区中的常量引用的对象。
            4.本地方法栈中JNI(即一般说的Native方法)的引用的对象。  
    
            都是不在堆中的对象，说白了就是检查，方法区，虚拟机栈，本地方法栈的引用。
    
    11.GC回收算法有哪些？
    1.标记-清除法：标记出没用的对象，然后一个一个回收
      缺点：标记和清除两个过程效率不高，产生内存碎片导致需要分配较大对象时无法找到足够的连续内存而需要触发一次GC操作。
    2.复制法：按照容量划分二个大小相等的内存区域，当一块用完的时候将活着的对象复制到另外一块。
      缺点：将内存缩小为了原来的一半。
    3.标记-整理法：标记出没有用的对象，让所有存活的对象都向一端移动，然后直接清除掉端边界以外的内。
      优点：解决了标记- 清除算法导致的内存碎片问题和在存活率较高时复制算法效率低的问题。
    4.分区回收：根据对象存活周期的不同将内存划分为几块，一般是新生代和老年代。
      新生代基本采用复制算法，老年代采用标记整理算法。
    
    12.MinorGC&FullGC区别？
    https://juejin.im/post/5b8d2a5551882542ba1ddcf8
    
    1.Minor GC通常发生在新生代的Eden区，在这个区的对象生存期短，往往发生GC的频率较高，回收速度比较快，一般采用复制-回收算法
    2.Full GC/Major GC 发生在老年代，一般情况下，触发老年代GC的时候不会触发Minor GC，所采用的是标记-清除算法。
    
    13.内存分配与回收策略？
    1.结构（堆大小 = 新生代 + 老年代 ）：
        新生代(1/3)(初始对象，生命周期短)：Eden 区、survivior 0、survivior 1（ 8 : 1 : 1）
        老年代(2/3)(长时间存在的对象)
    2.一般小型的对象都会在 Eden 区上分配，如果Eden区无法分配，那么尝试把活着的对象放到survivor0中去（Minor GC）
        如果survivor0可以放入，那么放入之后清除Eden区
        如果survivor0不可以放入，那么尝试把Eden和survivor0的存活对象放到survivor1中
            如果survivor1可以放入，那么放入survivor1之后清除Eden和survivor0，之后再把survivor1中的对象复制到survivor0中，保持survivor1一直为空。
            如果survivor1不可以放入，那么直接把它们放入到老年代中，并清除Eden和survivor0，这个过程也称为分配担保（Full GC）
    如果新egen中，被回收了15次，还存活的对象，直接进入到老年代。
    
    14.GC垃圾收集器
    Serial New收集器是针对新生代的收集器，采用的是复制算法
    Parallel New（并行）收集器，新生代采用复制算法，老年代采用标记整理
    Parallel Scavenge（并行）收集器，针对新生代，采用复制收集算法
    Serial Old（串行）收集器，新生代采用复制，老年代采用标记清理
    Parallel Old（并行）收集器，针对老年代，标记整理
    CMS收集器，基于标记清理
    G1收集器(JDK)：整体上是基于标记清理，局部采用复制
    综上：新生代基本采用复制算法，老年代采用标记整理算法。cms采用标记清理


    15.Java类加载机制
    1.概念：
        拟机把描述类的数据文件（字节码）加载到内存，并对数据进行验证、准备、解析以及类初始化，
        最终形成可以被虚拟机直接使用的java类型（java.lang.Class对象）。
    2.类的生命周期：
        1.加载阶段：
            通过一个类的全限定名来获取定义此类的二进制字节流，将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。在内存中(方法区)生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口。
            简单来说，生成一个Class对象到方法区中。
        2.验证阶段
            为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求，文件格式验证、元数据验证、字节码验证、符号引用验证。
            检查是否符合java虚拟机规则。
        3.准备阶段
            正式为类属性分配内存并设置 类属性 初始值的阶段，这些内存都将在方法区中进行分配。
        4.解析阶段
            虚拟机将常量池内的符号引用替换为直接引用的过程。因为一开始比如类有常量，然后在住准备阶段分配了常量，把常量引用解析到类中。
        5.初始化阶段
            类初始化阶段是类加载过程的最后一步。初始化阶段就是执行类构造器<clint>()方法的过程。
        6.使用阶段
        7.卸载阶段
    3.类加载机制：
        1.Bootstrap ClassLoader:根类加载器, 负责加载java的核心类，它不是java.lang.ClassLoader的子类，而是由JVM自身实现 c++实现的。
        2.Extension ClassLoader：扩展类加载器，扩展类加载器的加载路径是JDK目录下jre/lib/   ext,扩展类的getParent()方法返回null,实际上扩展类加载器的父类加载器是根加载器，只是根加载器并不是Java实现的。
        3.System ClassLoader:系统(应用)类加载器，它负责在JVM启动时加载来自java命令的-classpath选项、java.class.path系统属性或CLASSPATH环境变量所指定的jar包和类路径。程序可以通过getSystemClassLoader()来获取系统类加载器。系统加载器的加载路径是程序运行的当前路径。
    
    4.双亲委派模型的工作过程
        1.首先会先查找当前ClassLoader是否加载过此类，有就返回；
        2.如果没有，查询父ClassLoader是否已经加载过此类，如果已经加载过,就直接返回Parent加载的类；
        3.如果整个类加载器体系上的ClassLoader都没有加载过，才由当前ClassLoader加载(调用findClass)，整个过程类似循环链表一样。
    
    5.双亲委派机制的作用
        1.共享功能：可以避免重复加载，当父亲已经加载了该类的时候，子类不需要再次加载，一些Framework层级的类一旦被顶层的ClassLoader加载过就缓存在内存里面，以后任何地方用到都不需要重新加载。
        2.隔离功能：因为String已经在启动时被加载，所以用户自定义类是无法加载一个自定义的类装载器，保证java/Android核心类库的纯净和安全，防止恶意加载。
    
    6.如何打破双亲委派模型？
        1.双亲委派模型的逻辑都在loadClass()中，重写loaderClass()，一般是重写findClass()的。
        2.系统自带的三个类加载器都加载特定目录下的类，如果我们自己的类加载器放在一个特殊的目录，
        那么系统的加载器就无法加载，也就是最终还是由我们自己的加载器加载
    
    16.引起类加载操作的五个行为
    1.遇到new、getstatic、putstatic或invokestatic这四条字节码指令
    2.反射调用的时候，如果类没有进行过初始化，则需要先触发其初始化
    3.子类初始化的时候，如果其父类还没初始化，则需先触发其父类的初始化
    4.虚拟机执行主类的时候(有 main(string[] args))
    4.JDK1.7 动态语言支持
    
    17.Java对象创建时机
    1.使用new关键字创建对象
    2.使用Class类的newInstance方法(反射机制)
    3.使用Constructor类的newInstance方法(反射机制)
    4.使用Clone方法创建对象
    5.使用(反)序列化机制创建对象


    18.GC垃圾回收算法和垃圾收集器的关系？分别是什么？
    垃圾回收的方式：
        1.Serial 串行
        2.parallel 并行
        3.cms 并发
        4.G1
    
    垃圾收集器
        新生代
        老年代
            1.cms收集器（Concurrent Mark Sweep:并发标记清除）是一种以获取最短回收停顿时间为目的的收集器
                适合互联网站，b/s系统服务，这类应用重视响应速度，希望系统停顿时间最短。
                cms适合堆内存大，cpu核数多的服务端应用。
                特点：并发收集低停顿，并发指的是与用户线程一起执行。
            开启该收集器的jvm参数： -XX:+UseConcMarkSweepGC 开启该参数后会自动将-XX:UserParalNewGC开启
            使用parNew(Young区用)+cms(old区用)+ serial old的收集器组合，serial old作为cms出错后的备用收集器。
    
            4步过程：
                1.初始化标记（cms initial mark）用户线程暂停
                2.并发标记（cms concurrent mark）和用户线程一起工作
                3.重新标记（cms remark）用户线程暂停
                4.并发清除（cms concurrent sweep）和用户线程一起工作
            优缺点：
                优点：
                    并发收集停顿低
                缺点：
                    并发执行，对cpu资源压力大。
                    采用的标记清除算法会导致大量碎片。
            2.serial old
                是serial垃圾收集器老年代版本，兜底的收集器。
                目前无法配置了，理论知道就行。
    
            如何选择垃圾收集器：
                1.单cpu或者小内存，单机程序
                    -XX:+UseSerialGC
                2.多cpu，需要最大吞吐量，如后台计算型应用
                    -XX:+UseParallelGC 或者
                    -XX:+UseParallelOldGC
                3.多cpu, 追求低停顿时间，需快速响应如互联网应用
                    -XX:+UserConcMarkSweepGC
                    -XX:+ParNewGC
                新生代和老年代的收集器是配对出现的，所以只需配其中一个即可。
    
    
    
    

#####19.聊聊G1垃圾收集器，与cms的区别。
1.以前收集器的特点：
    1.年轻代和老年代是各自独立且连续的内存块。
    2.年轻代收集使用单eden+s0+s 进行复制算法。
    3.老年代手机必须扫描整个老年代区域。
    4.都是以尽可能少而快速地执行gc为设计原则。
2.g1收集器 是一款面向服务端应用的收集器。多处理器和大容量内存环境
    像cms收集器一样，能与应用程序线程并发执行。
    整理空闲空间更快
    需要更多时间来预测gc停顿时间
    不需要更大的java heap

    G1收集器的设计目的是取代cms收集器，它同cms相比：
        1.G1是一个有整理内存过程的垃圾收集器，不会产生很多内存碎片。
        2.G1的stop the world(stw)更可控，G1在停顿时间上添加了预测机智，用户可以指定期望停顿时间。
        java9开始，成为默认收集器。
    
    特点：
        1.G1能够充分利用多cpu，多核环境硬件条件，尽量缩短stw
        2.G1整体上采用标记-整理算法，局部是通过复制算法，不会产生内存碎片。
        3.宏观上看G1之中不再区分年轻代和老年代，把内存划分为多个独立的子区域（region）,可以理解为一个围棋棋盘
        4.G1收集器里面讲整个内存区都是混在一起的，但其本身依然在小范围内要进行年轻代和老年代的区分，保留了新生代和老年代
        但是他们不再是物理隔离的，而是一部分region的集合且不需要region是连续的，也就是说依然会采用不同的gc方式来处理不同区域。
        5.G1虽然也是分代收集器，但整个内存分区不存在物理上的年轻代与老年代的区别，也不需要完全独立的survivor(to space)堆做复制准备
        G1只有逻辑上的分代概念，或者说每个分区都可能随G1的运行在不同代之间前后切换。

3.底层原理：
    1.region区域化垃圾收集器：
        最大好处化整为0，避免全内存扫描，只需要按照区域来进行扫描即可。

##### 20.生产环境服务器变慢，诊断思路和性能评估谈谈，如何落地

##### 21.G1回收器和其他回收器有什么区别

#####22.垃圾回收为什么会停顿？哪些对象可能作为GCRoots?

##### 23.垃圾回收分代收集算法？为什么会有两个Survivor区？new一个对象会保存在哪里？

##### 24.Java内存模型?volatile关键字，使用场景？原子性的理解？先行发生原则？






