多线程篇：

##### 1.操作系统的线程和java线程状态有何区别？

**操作系统线程状态：**

​	新建

​	1.就绪

​	2.运行

​	3.阻塞

​	退出

![](./pic/操作系统线程状态.jpg)



**jvm线程状态：**

​	1.New

​	2.Runnable(Ready、Running)

​	3.Wating

​	4.Timed Waiting

​	5.Blocked

​	6.Terminated

![jvm线程状态](./pic/jvm线程状态.jpg)

##### 2.进程调度和线程调度的区别？

​	定义：

​		进程：进程是系统进行资源分配和调度的一个独立单位。

​		线程：CPU调度和分派的基本单位, 只拥有一点在运行中必不可少的资源(如程序计数器,一组寄存器和栈), 可共					享进程所拥有的全部资源。



线程调度：使用相同资源的`struct task_struct`之间的调度。

进程调度：使用不同资源的`struct task_struct`之间的调度。

​	区别：

1. 切换时的上下文开销。

2. 任务调度而导致的TLB不命中，缺页而导致的开销。

任务调度的主要开销：

1.  CPU执行任务调度的开销，主要是进程上下文切换的开销。
2.  任务调度后，CPU Cache/TLB不命中，导致缺页中断的开销。

上下文切换其实线程和进程差不多，但是由于线程是共享资源所以TLB不会变，但是恰恰相反进程的调度进程调度是不同资源的，很可能导致缺页，所以开销很大。



##### 3.线程的调度算法有哪些？

1.FCFS，先来先服务调度算法

2.短作业优先调度算法（抢占式/非抢占式）

3.高优先权优先调度算法

4.基于时间片轮转调度算法

https://blog.csdn.net/zh13487/article/details/83928284

![调度算法](./pic/调度算法.png)



##### 4.多线程如何在多个CPU上分布

通过cpu调度算法，如果运算量不大，则分配到同一个cpu进行切换运行多线程；反之，则多个cpu运行多线程。

##### 5.Thread Local的原理与适用场景

ThreadLocal 提供了线程本地的实例。它与普通变量的区别在于，每个使用该变量的线程都会初始化一个完全独立的实例副本。ThreadLocal 变量通常被`private static`修饰。当一个线程结束时，它所使用的所有 ThreadLocal 相对的实例副本都可被回收。

场景：**ThreadLocal 适用于每个线程需要自己独立的实例且该实例需要在多个方法中被使用，也即变量在线程间隔离而在方法或类间共享的场景**



##### 6、wait和sleep的区别？

|   区别   |                      wait()                       |                  sleep()                   |
| :------: | :-----------------------------------------------: | :----------------------------------------: |
| 使用地方 |        只能在同步块synchronized环境中调用         |           不需要，线程中使用即可           |
|  唤  醒  | 进入wait状态的线程能够被notify和notifyAll线程唤醒 | 进入sleeping状态的线程不能被notify方法唤醒 |
| 释放资源 |    wait方法在进入wait状态的时候会释放对象的锁     |               sleep方法不会                |
| 作用对象 |          针对一个被同步代码块加锁的对象           |            sleep是针对一个线程             |



##### 7、线程什么时候会进入sleep状态？

线程调用了sleep()方法。

##### 8、线程的同步机制？

什么是同步机制，同步机制就是**用于协调线程对临界资源（硬件打印机，磁盘文件，内存（变量，数组，队列等））的访问。**

**线程有几种同步机制：**

- 临界区

  临界区是一段独占对某些共享资源访问的代码，在任意时刻只允许一个线程对共享资源进行访问。

- 互斥量

  功能上跟临界区类似，不过可用于不同进程间的线程同步。

- 事件

  唤醒同步队列中的等待线程，只能唤醒一个来访问资源。

- 信号量

  信号量用于限制对临界资源的访问数量，保证了消费数量不会大于生产数量。如停车场，车位有限，有空的车位，新的汽车才能进。

**java中的同步机制：**

- synchronized

  每个java对象都有一个内置锁，用synchronized修饰方法或者代码块时，内置锁会保护整个方法或代码块，要想执行这个方法或者代码块必须获得其内置锁，运行时会加上内置锁，当运行结束时，内置锁会打开。由于同步是一种高开销的工作，所以尽量减少同步的内容，只需同步代码块就可以。

- ReentrantLock

  一个可重入的互斥锁 Lock，它具有与使用 synchronized 方法和语句所访问的隐式监视器锁相同的一些基本行为和语义，手动加锁释放锁；

  ReentrantLock有一个锁相关的获取计数器（AQS中的state???), 同一个线程获得锁后，可重复进入n次，但是也要释放n次。

- wait()/notify()/notifyAll()

  在 synchronized代码被执行期间，线程可以调用对象的wait()方法，释放对象锁标志，进入等待状态，并且可以调用notify()或者 notifyAll()方法通知正在等待的其他线程。notify()通知等待队列中的第一个线程，notifyAll()通知的是等待队列中的所有线程。

  注意点：**obj.wait()方法将使本线程挂起，并释放obj对象的monitor。只有其他线程调用obj对象的notify()或notifyAll()时，才可以被唤醒。obj.notifyAll()方法唤醒所有该obj对象相关的沉睡线程，然后被唤醒的众多线程开始竞争obj对象的monitor占有权，最终得到的那个线程会继续执行下去，但其他线程还将继续等待。
  obj.notify()方法是随机唤醒一个沉睡线程。
  wait，notify和notifyAll只能在同步控制方法或者同步控制块里面使用。**

- ThreadLocal

  JVM为每一个使用该变量的线程都提供一个变量值的副本，每一个线程都可以独立地改变自己的副本，而不会和其它线程的副本冲突。线程消失，ThreadLocal副本全被回收（**除非存在对这些副本的应用，因此容易发生内存泄漏 ，使用WeakReference来保存ThreadLocal，防止出现内存泄露的情况**）

  实现原理：`ThreadLocal`类中有一个`ThreadLocalMap`，用于存储每一个线程的变量的副本。`ThreadLocalMap`通过一个Entry的数组来保存`ThreadLocal`的值。其中，Entry对象中使用`WeakReference`来保存`ThreadLocal`，防止出现内存泄露的情况，所以`ThreadLocal`中数据存储不是用`HashMap`实现的，而是用`Entry[]`数组实现，用`ThreadLocal`的hash值来&长度作为下标，模拟Map。

   详细：[ThreadLocal原理详情：https://blog.csdn.net/wzy_1988/article/details/72625482](https://blog.csdn.net/wzy_1988/article/details/72625482)

2.5、java线程工作内存模型
2.6、volatile的原理 内存屏障 happenbefore
2.7、synchronized原理 monitorenter monitorexit
2.8、jvm对锁进行了什么优化
2.9、无锁 偏向锁 轻量级锁 重量级锁的升级过程
2.10、为什么要有自旋锁
2.11、用户态切换内核态为什么代价大
2.12、原子类实现原理

##### cas是什么?

版本号控制：
    数据表中加入一个version字段，表示数据被修改的次数，线程a更新值，同时会拿到version值，
    提交更新，version要等于刚才取出来的version值，否则就会一直重试。
    数据库：更新要提交版本大于当前版本才能执行更新 乐观锁。

cas(比较与交换)：
    有名的无锁算法，即使不加锁，也能实现多线程之间变量的同步。
    CAS算法涉及到三个操作数：
        1.需要读写的内存值 V
        2.进行比较的值 A
        3.拟写入的新值 B
    当且仅当 V 的值等于 A时，CAS通过原子方式用新值B来更新V的值，否则不会执行任何操作（比较和替换是一个原子操作）。一般情况下是一个自旋操作，即不断的重试。

缺点：
    1.ABA问题：b线程可能把值改了又改回去，a线程是无法感知的。
      解决办法，加个版本号，jdk1.5 atiomicStampedReference 当前引用是否等于预期引用，当前标志是否等于预期标志。
    2.循环时间开销大：
      自旋CAS（也就是不成功就一直循环执行直到成功）如果长时间不成功，会给CPU带来非常大的执行开销
    3.只能保证一个共享变量的原子性，当操作涉及跨多个共享变量时 CAS 无效。
        从 JDK 1.5开始，提供了AtomicReference类来保证引用对象之间的原子性，你可以把多个变量放在一个对象里来进行 CAS 操作.所以我们可以使用锁或者利用AtomicReference类把多个共享变量合并成一个共享变量来操作。

2.13、如何评估线程池参数
2.13、线程池核心参数及其原理
2.13、线程池能不能动态修改容量
2.13、线程池 等待队列中的任务何时被执行

    1.看周阳视频
    2.乐观锁与悲观锁的区别？
    1.乐观锁：假设最好情况，每次线程去拿数据的时候，认为别人是不会改变的，不加锁，操作完，更新数据，检查有没有人更新过，通过版本号控制，cas算法实现。
        优点：
            1.多用于读取的应用类型，提高吞吐量。
        场景：多用于读场景
    
    2.悲观锁：假设最坏情况，每次拿数据，都得上锁，认为被人会修改。独占锁，
        例如共享资源，只允许一个线程使用，阻塞。像sychronized, reentrantlock都是悲观锁的思想。
        优点：安全
        场景：多用于写场景
    
    CAS与synchronized的使用情景：
        1.CAS适用于写比较少的情况下（多读场景，冲突一般较少）
            1.cas基于硬件实现的原语操作，不需要进入内核，不需要切换线程，写少，冲突少，自旋少，高性能。
    
            2.对于资源竞争严重（线程冲突严重）的情况，CAS自旋的概率会比较大，从而浪费更多的CPU资源，效率低于synchronized。
    
        2.synchronized适用于写比较多的情况下（多写场景，冲突一般较多）
            synchronized的底层实现主要依靠 Lock-Free 的队列，基本思路是 自旋后阻塞，竞争切换后继续竞争锁，稍微牺牲了公平性，但获得了高吞吐量。在线程冲突较少的情况下，可以获得和CAS类似的性能；而线程冲突严重的情况下，性能远高于CAS。




    4.什么是线程？
    线程是操作系统能够进行运算调度的最小单位，它被包含在进程之中，是进程中的实际运作单位，可以使用多线程对进行运算提速。
    
    5.什么是线程安全和线程不安全？
    加锁的就是是线程安全的，不加锁的就是是线程不安全的。
    
    6.什么是自旋锁？
    自旋锁是SMP架构中的一种low-level的同步机制。
    当线程A想要获取一把自选锁而该锁又被其它线程锁持有时，线程A会在一个循环中自选以检测锁是不是已经可用了。
    注意：
        1.由于自旋时不释放CPU，因而持有自旋锁的线程应该尽快释放自旋锁，否则等待该自旋锁的线程会一直在那里自旋，这就会浪费CPU时间。
        2.持有自旋锁的线程在sleep之前应该释放自旋锁以便其它线程可以获得自旋锁。
    实现：
    public class MyWaitNotify3{
        MontiorObject myMonitorObject = new MonitorObject();
        boolean wasSignalled = false;
    
        public void doWait(){
            sychronized(myMonitorObject){
                while(!wasSignalled){
                    try{
                        myMonitorObject.wait();
                    }catch(InterruptedException e){...}
                }
                
            }
        }
    
        public  void doNotify(){
            synchronized(myMonitorObject){
              wasSignalled = true;
              myMonitorObject.notify();
            }
        }
    }
    
    7.什么是Java内存模型？
    Java内存模型描述了在多线程代码中哪些行为是合法的，以及线程如何通过内存进行交互。它描述了“程序中的变量“ 和 ”从内存或者寄存器获取或存储它们的底层细节”之间的关系。Java内存模型通过使用各种各样的硬件和编译器的优化来正确实现以上事情。
    
    8.ThreadPool（线程池）用法与优势？
        线程池的基本思想是一种对象池，在程序启动时就开辟一块内存空间，里面存放了众多(未死亡)的线程，
        池中线程执行调度由池管理器来处理。当有线程任务时，从池中取一个，执行完成后线程对象归池，
        这样可以避免反复创建线程对象所带来的性能开销，节省了系统的资源
    1.使用场景：
        1.单个任务处理时间比较短。
        2.需要处理的任务数量很大。
    2.好处：
        1.降低资源消耗，通过重复利用已创建的线程降低线程创建和销毁造成的消耗。
        2.提高响应速度，当任务到达，不需要等到线程创建就能立刻执行。
        3.提高线程的可管理性，线程池可以统一分配线程资源，调优和监控。比如：延时执行、定时循环执行的策略等




    怎么才算是阻塞，具体表现是怎么样，会消耗系统资源吗
    https://zhuanlan.zhihu.com/p/34678757
    什么是AQS？
    什么是原子操作？在Java Concurrency API中有哪些原子类(atomic classes)？
    什么是Executors框架？
    什么是阻塞队列？如何使用阻塞队列来实现生产者-消费者模型？
    什么是Callable和Future?
    什么是FutureTask?
    什么是同步容器和并发容器的实现？
    什么是多线程？优缺点？
    什么是多线程的上下文切换？
    ThreadLocal的设计理念与作用？
    
    Concurrent包里的其他东西：ArrayBlockingQueue、CountDownLatch等等。
    synchronized和ReentrantLock的区别？
    Semaphore有什么作用？
    Java Concurrency API中的Lock接口(Lock interface)是什么？对比同步它有什么优势？
    Hashtable的size()方法中明明只有一条语句”return count”，为什么还要做同步？
    ConcurrentHashMap的并发度是什么？
    ReentrantReadWriteLock读写锁的使用？
    CyclicBarrier和CountDownLatch的用法及区别？
    LockSupport工具？
    Condition接口及其实现原理？
    Fork/Join框架的理解?
    wait()和sleep()的区别?
    线程的五个状态（五种状态，创建、就绪、运行、阻塞和死亡）?
    start()方法和run()方法的区别？
    Runnable接口和Callable接口的区别？
    volatile关键字的作用？
    Java中如何获取到线程dump文件？
    线程和进程有什么区别？
    线程实现的方式有几种（四种）？
    高并发、任务执行时间短的业务怎样使用线程池？并发不高、任务执行时间长的业务怎样使用线程池？并发高、业务执行时间长的业务怎样使用线程池？
    如果你提交任务时，线程池队列已满，这时会发生什么？
    锁的等级：方法锁、对象锁、类锁?
    如果同步块内的线程抛出异常会发生什么？
    并发编程（concurrency）并行编程（parallellism）有什么区别？
    如何保证多线程下 i++ 结果正确？
    一个线程如果出现了运行时异常会怎么样?
    如何在两个线程之间共享数据?
    生产者消费者模型的作用是什么?
    怎么唤醒一个阻塞的线程?
    Java中用到的线程调度算法是什么
    单例模式的线程安全性?
    线程类的构造方法、静态块是被哪个线程调用的?
    同步方法和同步块，哪个是更好的选择?
    如何检测死锁？怎么预防死锁？
    
    
    
    
    4.sychronized?
    https://juejin.im/post/5c936018f265da60ec281bcb
        可以发现synchronized同步代码块是通过加monitorenter和monitorexit指令实现的。
        每个对象都有个**监视器锁(monitor) **，当monitor被占用的时候就代表对象处于锁定状态，而monitorenter指令的作用就是获取monitor的所有权，monitorexit的作用是释放monitor的所有权，这两者的工作流程如下：
        monitorenter：
        
        如果monitor的进入数为0，则线程进入到monitor，然后将进入数设置为1，该线程称为monitor的所有者。
        如果是线程已经拥有此monitor(即monitor进入数不为0)，然后该线程又重新进入monitor，则将monitor的进入数+1，这个即为锁的重入。
        如果其他线程已经占用了monitor，则该线程进入到阻塞状态，知道monitor的进入数为0，该线程再去重新尝试获取monitor的所有权。
        
        monitorexit：执行该指令的线程必须是monitor的所有者，指令执行时，monitor进入数-1，如果-1后进入数为0，那么线程退出monitor，不再是这个monitor的所有者。这个时候其它阻塞的线程可以尝试获取monitor的所有权。
    
    5.reentrantlock?
    6.各种锁



