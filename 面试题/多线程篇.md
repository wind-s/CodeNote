![多线程篇封面.jpeg](./pic/多线程篇封面.jpeg)

多线程篇：

> 面试过程中，多线程是非常重要的一部分，因此，本文收集了常问的面试题，以及参考答案，欢迎一起学习交流。

##### 1.操作系统的线程和java线程状态有何区别？

**操作系统线程状态：**

- 新建
- 1.就绪
- 2.运行
- 3.阻塞
- 退出

![](./pic/操作系统线程状态.jpg)



**jvm线程状态：**

- 1.New
- 2.Runnable(Ready、Running)

- 3.Wating

- 4.Timed Waiting
- 5.Blocked
- 6.Terminated

![jvm线程状态](./pic/jvm线程状态.jpg)

##### 2.进程调度和线程调度的区别？

​	定义：

- 进程：进程是系统进行资源分配和调度的一个独立单位。
- 线程：CPU调度和分派的基本单位, 只拥有一点在运行中必不可少的资源(如程序计数器,一组寄存器和栈), 		可共享进程所拥有的全部资源。

- 线程调度：使用相同资源的`struct task_struct`之间的调度。
- 进程调度：使用不同资源的`struct task_struct`之间的调度。

​	区别：

1. 切换时的上下文开销。

2. 任务调度而导致的TLB不命中，缺页而导致的开销。

任务调度的主要开销：

1.  CPU执行任务调度的开销，主要是进程上下文切换的开销。
2.  任务调度后，CPU Cache/TLB不命中，导致缺页中断的开销。

上下文切换其实线程和进程差不多，但是由于线程是共享资源所以TLB不会变，但是恰恰相反进程的调度进程调度是不同资源的，很可能导致缺页，所以开销很大。



##### 3.线程的调度算法有哪些？

1.FCFS，先来先服务调度算法

2.短作业优先调度算法（抢占式/非抢占式）

3.高优先权优先调度算法

4.基于时间片轮转调度算法

https://blog.csdn.net/zh13487/article/details/83928284

![调度算法](./pic/调度算法.png)



##### 4.多线程如何在多个CPU上分布

通过cpu调度算法，如果运算量不大，则分配到同一个cpu进行切换运行多线程；反之，则多个cpu运行多线程。

##### 5.Thread Local的原理与适用场景

ThreadLocal 提供了线程本地的实例。它与普通变量的区别在于，每个使用该变量的线程都会初始化一个完全独立的实例副本。ThreadLocal 变量通常被`private static`修饰。当一个线程结束时，它所使用的所有 ThreadLocal 相对的实例副本都可被回收。

场景：**ThreadLocal 适用于每个线程需要自己独立的实例且该实例需要在多个方法中被使用，也即变量在线程间隔离而在方法或类间共享的场景**



##### 6、wait和sleep的区别？

|   区别   |                      wait()                       |                  sleep()                   |
| :------: | :-----------------------------------------------: | :----------------------------------------: |
| 使用地方 |        只能在同步块synchronized环境中调用         |           不需要，线程中使用即可           |
|  唤  醒  | 进入wait状态的线程能够被notify和notifyAll线程唤醒 | 进入sleeping状态的线程不能被notify方法唤醒 |
| 释放资源 |    wait方法在进入wait状态的时候会释放对象的锁     |               sleep方法不会                |
| 作用对象 |          针对一个被同步代码块加锁的对象           |            sleep是针对一个线程             |



##### 7、线程什么时候会进入sleep状态？

线程调用了sleep()方法。

##### 8、线程的同步机制？

什么是同步机制，同步机制就是**用于协调线程对临界资源（硬件打印机，磁盘文件，内存（变量，数组，队列等））的访问。**

**线程有几种同步机制：**

- 临界区

  临界区是一段独占对某些共享资源访问的代码，在任意时刻只允许一个线程对共享资源进行访问。

- 互斥量

  功能上跟临界区类似，不过可用于不同进程间的线程同步。

- 事件

  唤醒同步队列中的等待线程，只能唤醒一个来访问资源。

- 信号量

  信号量用于限制对临界资源的访问数量，保证了消费数量不会大于生产数量。如停车场，车位有限，有空的车位，新的汽车才能进。

**java中的同步机制：**

- synchronized

  每个java对象都有一个内置锁，用synchronized修饰方法或者代码块时，内置锁会保护整个方法或代码块，要想执行这个方法或者代码块必须获得其内置锁，运行时会加上内置锁，当运行结束时，内置锁会打开。由于同步是一种高开销的工作，所以尽量减少同步的内容，只需同步代码块就可以。

- ReentrantLock

  一个可重入的互斥锁 Lock，它具有与使用 synchronized 方法和语句所访问的隐式监视器锁相同的一些基本行为和语义，手动加锁释放锁；

  ReentrantLock有一个锁相关的获取计数器（AQS中的state???), 同一个线程获得锁后，可重复进入n次，但是也要释放n次。

- wait()/notify()/notifyAll()

  在 synchronized代码被执行期间，线程可以调用对象的wait()方法，释放对象锁标志，进入等待状态，并且可以调用notify()或者 notifyAll()方法通知正在等待的其他线程。notify()通知等待队列中的第一个线程，notifyAll()通知的是等待队列中的所有线程。

  注意点：**obj.wait()方法将使本线程挂起，并释放obj对象的monitor。只有其他线程调用obj对象的notify()或notifyAll()时，才可以被唤醒。obj.notifyAll()方法唤醒所有该obj对象相关的沉睡线程，然后被唤醒的众多线程开始竞争obj对象的monitor占有权，最终得到的那个线程会继续执行下去，但其他线程还将继续等待。
  obj.notify()方法是随机唤醒一个沉睡线程。
  wait，notify和notifyAll只能在同步控制方法或者同步控制块里面使用。**

- ThreadLocal

  JVM为每一个使用该变量的线程都提供一个变量值的副本，每一个线程都可以独立地改变自己的副本，而不会和其它线程的副本冲突。线程消失，ThreadLocal副本全被回收（**除非存在对这些副本的应用，因此容易发生内存泄漏 ，使用WeakReference来保存ThreadLocal，防止出现内存泄露的情况**）

  实现原理：`ThreadLocal`类中有一个`ThreadLocalMap`，用于存储每一个线程的变量的副本。`ThreadLocalMap`通过一个Entry的数组来保存`ThreadLocal`的值。其中，Entry对象中使用`WeakReference`来保存`ThreadLocal`，防止出现内存泄露的情况，所以`ThreadLocal`中数据存储不是用`HashMap`实现的，而是用`Entry[]`数组实现，用`ThreadLocal`的hash值来&长度作为下标，模拟Map。

   详细：[ThreadLocal原理详情：https://blog.csdn.net/wzy_1988/article/details/72625482](https://blog.csdn.net/wzy_1988/article/details/72625482)

##### 9、java线程工作内存模型 

作用：**屏蔽各种硬件和操作系统的内存访问差异，以实现让java程序在各种平台下达到一致的并发效果。**

java内存模型目的：

- 定义程序中各个变量的访问规则，在虚拟机中将变量存储到内存和从内存中取出变量的底层细节。
- 规定所有变量都存储在主内存（类比电脑硬件的内存）中，每个线程有自己的工作内存（高速缓存之类的）
- 线程对变量的操作只能在工作内存中完成，不同线程直接不能直接访问对方的工作内存的变量。

线程，工作内存，主内存交互流程图如下：

例子代码：

```
public class HelloWorld{
	private int a = 0;
	public void incr(){
		a++;
	}
}

HelloWorld hello = new HellWorld();

//线程1
new Thread(){
	public void run(){
		hello.incr();
	}
}.start();

//线程2
new Thread(){
	public void run(){
		hello.incr();
	}
}.start();
```



交互流程图如下：

![java内存模型交互流程图](./pic/java内存模型交互.png)

##### 10、什么是线程安全？

定义：**“当多个线程访问一个对象时，如果不用考虑这些线程在运行时环境下的调度和交替执行，也不需要进行额外的同步，或者在调用方进行任何其他的协调操作，调用这个对象的行为都可以获得正确的结果，那这个对象是线程安全的”。**

要求：**“代码本身封装了所有必要的正确性保障手段（如互斥同步等），令调用者无须关心多线程的问题，更无须自己采取任何措施来保证多线程的正确调用。”**

##### 11、jvm对线程锁的优化有哪些？

- 自旋锁

  同步代码执行的时间很短，没必要去刮起和恢复竞争的线程，因为让竞争资源的线程进行循环。默认自旋次数10次。

  >优点：自旋本身避免了线程切换的开销，如果锁的占用时间很短，自旋效果就很好。
  >
  >缺点: 如果锁占用时间长，自旋浪费cpu资源，

- 自适应性自旋锁

  自旋时间根据前一次在同一个锁上的自旋时间及锁的拥有者状态来决定，若上一次自旋成功，这次jvm会给更长的时间自旋；若自旋很少成功，jvm就直接省略自旋的过程，避免浪费cpu资源。

- 锁消除

  虚拟机即时编译器在运行时，对一些代码上要求同步，但是被检测到不可能存在共享数据竞争的锁进行消除。

  ```
  public String concatString（String s1，String s2，String s3）{
  	return s1+s2+s3；
  }
  
  ```

  String是一个不可变的类，对于字符串的连接操作会生成新的string对象进行，jvm对string连接做优化后：

  ```
  public String concatString（String s1，String s2，String s3）{
  	StringBuffer sb=new StringBuffer()；
  	sb.append（s1）；
  	sb.append（s2）；
  	sb.append（s3）；
  	return sb.toString()；
  }
  ```

  每个append方法中都有个同步代码块，但是jvm检测到这个sb的所有引用不会逃逸到方法外，因为可以消除锁。多次加锁变成一次加锁。

- 锁粗化

  虚拟机探测到有这样一串零碎的操作都对同一个对象加锁，将会把加锁同步的范围扩展（粗化）到整个操作序列的外部。

  例子同上，

- 轻量级锁

“轻量级”是相对于使用操作系统互斥量来实现的传统锁而言的，因此传统的锁机制就称为“重量级”锁。轻量级锁并不是用来代替重量级锁的，它的本意是在没有多线程竞争的前提下，减少传统的重量级锁使用操作系统互斥量产生的性能消耗。

要了解轻量级锁，就得先知道对象头的构造。

markword，markword是java对象数据结构中的一部分，对象的markword和java各种类型的锁密切相关。

结构如下：



![markword结构](./pic/markword结构.png)

**轻量级锁加锁的过程：**

1.在代码进入同步块的时候，如果同步对象锁状态为无锁状态（锁标志位为“01”状态，是否为偏向锁为“0”），虚拟机首先将在当前线程的栈帧中建立一个名为锁记录（Lock Record）的空间，用于存储锁对象目前的Mark Word的拷贝，官方称之为 Displaced Mark Word。这时候线程堆栈与对象头的状态如图：
![轻量级锁加锁线程堆栈与对象头的状态](./pic/轻量级锁加锁1.png)

2.拷贝对象头中的Mark Word复制到锁记录中。

3.拷贝成功后，虚拟机将使用CAS操作尝试将对象的Mark Word更新为指向Lock Record的指针，并将Lock record里的owner指针指向object mark word。如果更新成功，则执行步骤4，否则执行步骤5。

![锁对象的markword指向](./pic/锁对象的markword指向.jpeg)

4.如果这个更新动作成功了，那么这个线程就拥有了该对象的锁，并且对象Mark Word的锁标志位设置为“00”，即表示此对象处于轻量级锁定状态。

5.如果这个更新操作失败了，虚拟机首先会检查对象的Mark Word是否指向当前线程的栈帧，如果是就说明当前线程已经拥有了这个对象的锁，那就可以直接进入同步块继续执行。否则说明多个线程竞争锁，轻量级锁就要膨胀为重量级锁，锁标志的状态值变为“10”，Mark Word中存储的就是指向重量级锁（互斥量）的指针，后面等待锁的线程也要进入阻塞状态。 而当前线程便尝试使用自旋来获取锁，自旋就是为了不让线程阻塞，而采用循环去获取锁的过程。

**轻量级锁的释放：**

- 释放锁线程视角：由轻量锁切换到重量锁，是发生在轻量锁释放锁的期间，之前在获取锁的时候它拷贝了锁对象头的markword，在释放锁的时候如果它发现在它持有锁的期间有其他线程来尝试获取锁了，并且该线程对markword做了修改，两者比对发现不一致，则切换到重量锁。

  因为重量级锁被修改了，所有display mark word和原来的markword不一样了。

  怎么补救，就是进入mutex前，compare一下obj的markword状态。确认该markword是否被其他线程持有。

  此时如果线程已经释放了markword，那么通过CAS后就可以直接进入线程，无需进入mutex，就这个作用。

  

  - 尝试获取锁线程视角：如果线程尝试获取锁的时候，轻量锁正被其他线程占有，那么它就会修改markword，修改重量级锁，表示该进入重量锁了。

  还有一个注意点：等待轻量锁的线程不会阻塞，它会一直自旋等待锁，并如上所说修改markword。

  这就是自旋锁，尝试获取锁的线程，在没有获得锁的时候，不被挂起，而转而去执行一个空循环，即自旋。在若干个自旋后，如果还没有获得锁，则才被挂起，获得锁，则执行代码。

##### synchronized的执行过程

1. 检测Mark Word里面是不是当前线程的ID，如果是，表示当前线程处于偏向锁
2. 如果不是，则使用CAS将当前线程的ID替换Mard Word，如果成功则表示当前线程获得偏向锁，置偏向标志位1
3. 如果失败，则说明发生竞争，撤销偏向锁，进而升级为轻量级锁。
4. 当前线程使用CAS将对象头的Mark Word替换为锁记录指针，如果成功，当前线程获得锁
5. 如果失败，表示其他线程竞争锁，当前线程便尝试使用自旋来获取锁。
6. 如果自旋成功则依然处于轻量级状态。
7. 如果自旋失败，则升级为重量级锁。


##### 12、无锁 偏向锁 轻量级锁 重量级锁的升级过程

详情：https://blog.csdn.net/zqz_zqz/article/details/70233767

##### 13、用户态切换内核态为什么代价大

在JDK1.6及其之前的版本中monitorenter和monitorexit字节码依赖于底层的操作系统的Mutex Lock来实现的，但是由于使用Mutex Lock需要将当前线程挂起并从用户态切换到内核态来执行，这种切换的代价是非常昂贵的。然而在现实中的大部分情况下，同步方法是运行在单线程环境（无锁竞争环境）。如果每次都调用Mutex Lock将严重的影响程序的性能。因此在JDK 1.6之后的版本中对锁的实现做了大量的优化，这些优化在很大程度上减少或避免了Mutex Lock的使用。

#####14、原子类实现原理

Cas

##### cas是什么?

版本号控制：
    数据表中加入一个version字段，表示数据被修改的次数，线程a更新值，同时会拿到version值，
    提交更新，version要等于刚才取出来的version值，否则就会一直重试。
    数据库：更新要提交版本大于当前版本才能执行更新 乐观锁。

cas(比较与交换)：
    有名的无锁算法，即使不加锁，也能实现多线程之间变量的同步。
    CAS算法涉及到三个操作数：
        1.需要读写的内存值 V
        2.进行比较的值 A
        3.拟写入的新值 B
    当且仅当 V 的值等于 A时，CAS通过原子方式用新值B来更新V的值，否则不会执行任何操作（比较和替换是一个原子操作）。一般情况下是一个自旋操作，即不断的重试。

缺点：
    1.ABA问题：b线程可能把值改了又改回去，a线程是无法感知的。
      解决办法，加个版本号，jdk1.5 atiomicStampedReference 当前引用是否等于预期引用，当前标志是否等于预期标志。
    2.循环时间开销大：
      自旋CAS（也就是不成功就一直循环执行直到成功）如果长时间不成功，会给CPU带来非常大的执行开销
    3.只能保证一个共享变量的原子性，当操作涉及跨多个共享变量时 CAS 无效。
        从 JDK 1.5开始，提供了AtomicReference类来保证引用对象之间的原子性，你可以把多个变量放在一个对象里来进行 CAS 操作.所以我们可以使用锁或者利用AtomicReference类把多个共享变量合并成一个共享变量来操作。





##### 15、线程池能不能动态修改容量？

JDK允许线程池使用方通过ThreadPoolExecutor的实例来动态设置线程池的核心策略，以setCorePoolSize为方法例，在运行期线程池使用方调用此方法设置corePoolSize之后，线程池会直接覆盖原来的corePoolSize值，并且基于当前值和原始值的比较结果采取不同的处理策略。

- 对于当前值小于当前工作线程数的情况，说明有多余的worker线程，此时会向当前idle的worker线程发起中断请求以实现回收，多余的worker在下次idel的时候也会被回收；

- 对于当前值大于原始值且当前队列中有待执行任务，则线程池会创建新的worker线程来执行队列任务，setCorePoolSize具体流程如下

   ![线程池参数动态修改流程](./pic/线程池参数动态修改流程.png)

详情：https://tech.meituan.com/2020/04/02/java-pooling-pratice-in-meituan.html

##### 16、如何评估线程池参数

业界一些参数配置：

![线程池参数配置](./pic/线程池参数配置.png)

这样计算出来的参数都不合理，因此需要动态调节线程池的参数。



非要有个计算方式：

```
利特尔法则（Little’s law）：一个系统请求数等于请求的到达率与平均每个单独请求花费的时间之乘积。

依托利特尔法则通常根据3个要素来确定线程池参数设置；

（1）tasks ：每秒的任务数，假设为500~1000

        （2）taskcost：每个任务花费时间，假设为0.1s

        （3）responsetime：系统允许容忍的最大响应时间，假设为1s       

另外基于实践有以下几个配置公式：

1、corePoolSize = 每秒需要多少个线程处理=tasks/(1/taskcost) =tasks*taskcost

2、queueCapacity = (coreSizePool/taskcost)*responsetime

3、maxPoolSize = (max(tasks)- queueCapacity)/(1/taskcost)

保持疑问

```



##### 17、线程池核心参数及其原理

1.corePoolSize 线程池中的核心线程数。

- 创建了线程后， 当有请求任务来了之后，就会安排池中的线程去执行请求任务，近似理解为今日当值线程。
- 当线程池中的线程数目达到corePoolSize后，就会把到达的任务放到缓存队列中。

2.maxPoolSize, 线程池能够容纳同时执行的最大线程数，此值必须大于等于1。

3.keepAliveTime：多余空闲线程的存活时间。当线程池的数量超过corePoolSize, 并且空闲时间达到keepAliveTime值时，多余空闲线程会被销毁直到只剩下corePoolSize个线程为止。

- 默认情况下，只有当线程池中的线程数大于corePoolSize时，keepAliveTime才会起作用，直到线程池中的线程数不大于corePoolSize。

4.unit, keepAliveTime的单位。

5.workQueue，阻塞队列
（类似银行的候客区）

6.threadFactory，线程池默认的配置

- 例如银行网点的全部东西（logo,工作制服，胸卡）

7.handler，线程池的拒绝策略

- 例如maxPoolSizez最大线程数已经满了，都在处理任务，阻塞队列已满，线程池就开始执行拒绝策略（银行门口挂牌，请到其他网点处理）



2.13、线程池 等待队列中的任务何时被执行

    1.看周阳视频
    2.乐观锁与悲观锁的区别？
    1.乐观锁：假设最好情况，每次线程去拿数据的时候，认为别人是不会改变的，不加锁，操作完，更新数据，检查有没有人更新过，通过版本号控制，cas算法实现。
        优点：
            1.多用于读取的应用类型，提高吞吐量。
        场景：多用于读场景
    
    2.悲观锁：假设最坏情况，每次拿数据，都得上锁，认为被人会修改。独占锁，
        例如共享资源，只允许一个线程使用，阻塞。像sychronized, reentrantlock都是悲观锁的思想。
        优点：安全
        场景：多用于写场景
    
    CAS与synchronized的使用情景：
        1.CAS适用于写比较少的情况下（多读场景，冲突一般较少）
            1.cas基于硬件实现的原语操作，不需要进入内核，不需要切换线程，写少，冲突少，自旋少，高性能。
    
            2.对于资源竞争严重（线程冲突严重）的情况，CAS自旋的概率会比较大，从而浪费更多的CPU资源，效率低于synchronized。
    
        2.synchronized适用于写比较多的情况下（多写场景，冲突一般较多）
            synchronized的底层实现主要依靠 Lock-Free 的队列，基本思路是 自旋后阻塞，竞争切换后继续竞争锁，稍微牺牲了公平性，但获得了高吞吐量。在线程冲突较少的情况下，可以获得和CAS类似的性能；而线程冲突严重的情况下，性能远高于CAS。




    4.什么是线程？
    线程是操作系统能够进行运算调度的最小单位，它被包含在进程之中，是进程中的实际运作单位，可以使用多线程对进行运算提速。
    
    5.什么是线程安全和线程不安全？
    加锁的就是是线程安全的，不加锁的就是是线程不安全的。
    
    6.什么是自旋锁？
    自旋锁是SMP架构中的一种low-level的同步机制。
    当线程A想要获取一把自选锁而该锁又被其它线程锁持有时，线程A会在一个循环中自选以检测锁是不是已经可用了。
    注意：
        1.由于自旋时不释放CPU，因而持有自旋锁的线程应该尽快释放自旋锁，否则等待该自旋锁的线程会一直在那里自旋，这就会浪费CPU时间。
        2.持有自旋锁的线程在sleep之前应该释放自旋锁以便其它线程可以获得自旋锁。
    实现：
    public class MyWaitNotify3{
        MontiorObject myMonitorObject = new MonitorObject();
        boolean wasSignalled = false;
    
        public void doWait(){
            sychronized(myMonitorObject){
                while(!wasSignalled){
                    try{
                        myMonitorObject.wait();
                    }catch(InterruptedException e){...}
                }
                
            }
        }
    
        public  void doNotify(){
            synchronized(myMonitorObject){
              wasSignalled = true;
              myMonitorObject.notify();
            }
        }
    }
    
    7.什么是Java内存模型？
    Java内存模型描述了在多线程代码中哪些行为是合法的，以及线程如何通过内存进行交互。它描述了“程序中的变量“ 和 ”从内存或者寄存器获取或存储它们的底层细节”之间的关系。Java内存模型通过使用各种各样的硬件和编译器的优化来正确实现以上事情。
    
    8.ThreadPool（线程池）用法与优势？
        线程池的基本思想是一种对象池，在程序启动时就开辟一块内存空间，里面存放了众多(未死亡)的线程，
        池中线程执行调度由池管理器来处理。当有线程任务时，从池中取一个，执行完成后线程对象归池，
        这样可以避免反复创建线程对象所带来的性能开销，节省了系统的资源
    1.使用场景：
        1.单个任务处理时间比较短。
        2.需要处理的任务数量很大。
    2.好处：
        1.降低资源消耗，通过重复利用已创建的线程降低线程创建和销毁造成的消耗。
        2.提高响应速度，当任务到达，不需要等到线程创建就能立刻执行。
        3.提高线程的可管理性，线程池可以统一分配线程资源，调优和监控。比如：延时执行、定时循环执行的策略等




    怎么才算是阻塞，具体表现是怎么样，会消耗系统资源吗
    https://zhuanlan.zhihu.com/p/34678757
    什么是AQS？
    什么是原子操作？在Java Concurrency API中有哪些原子类(atomic classes)？
    什么是Executors框架？
    什么是阻塞队列？如何使用阻塞队列来实现生产者-消费者模型？
    什么是Callable和Future?
    什么是FutureTask?
    什么是同步容器和并发容器的实现？
    什么是多线程？优缺点？
    什么是多线程的上下文切换？
    ThreadLocal的设计理念与作用？
    
    Concurrent包里的其他东西：ArrayBlockingQueue、CountDownLatch等等。
    synchronized和ReentrantLock的区别？
    Semaphore有什么作用？
    Java Concurrency API中的Lock接口(Lock interface)是什么？对比同步它有什么优势？
    Hashtable的size()方法中明明只有一条语句”return count”，为什么还要做同步？
    ConcurrentHashMap的并发度是什么？
    ReentrantReadWriteLock读写锁的使用？
    CyclicBarrier和CountDownLatch的用法及区别？
    LockSupport工具？
    Condition接口及其实现原理？
    Fork/Join框架的理解?
    wait()和sleep()的区别?
    线程的五个状态（五种状态，创建、就绪、运行、阻塞和死亡）?
    start()方法和run()方法的区别？
    Runnable接口和Callable接口的区别？
    volatile关键字的作用？
    Java中如何获取到线程dump文件？
    线程和进程有什么区别？
    线程实现的方式有几种（四种）？
    高并发、任务执行时间短的业务怎样使用线程池？并发不高、任务执行时间长的业务怎样使用线程池？并发高、业务执行时间长的业务怎样使用线程池？
    如果你提交任务时，线程池队列已满，这时会发生什么？
    锁的等级：方法锁、对象锁、类锁?
    如果同步块内的线程抛出异常会发生什么？
    并发编程（concurrency）并行编程（parallellism）有什么区别？
    如何保证多线程下 i++ 结果正确？
    一个线程如果出现了运行时异常会怎么样?
    如何在两个线程之间共享数据?
    生产者消费者模型的作用是什么?
    怎么唤醒一个阻塞的线程?
    Java中用到的线程调度算法是什么
    单例模式的线程安全性?
    线程类的构造方法、静态块是被哪个线程调用的?
    同步方法和同步块，哪个是更好的选择?
    如何检测死锁？怎么预防死锁？


​    
​    
​    
​    4.sychronized?
​    https://juejin.im/post/5c936018f265da60ec281bcb
​        可以发现synchronized同步代码块是通过加monitorenter和monitorexit指令实现的。
​        每个对象都有个**监视器锁(monitor) **，当monitor被占用的时候就代表对象处于锁定状态，而monitorenter指令的作用就是获取monitor的所有权，monitorexit的作用是释放monitor的所有权，这两者的工作流程如下：
​        monitorenter：
​        
        如果monitor的进入数为0，则线程进入到monitor，然后将进入数设置为1，该线程称为monitor的所有者。
        如果是线程已经拥有此monitor(即monitor进入数不为0)，然后该线程又重新进入monitor，则将monitor的进入数+1，这个即为锁的重入。
        如果其他线程已经占用了monitor，则该线程进入到阻塞状态，知道monitor的进入数为0，该线程再去重新尝试获取monitor的所有权。
        
        monitorexit：执行该指令的线程必须是monitor的所有者，指令执行时，monitor进入数-1，如果-1后进入数为0，那么线程退出monitor，不再是这个monitor的所有者。这个时候其它阻塞的线程可以尝试获取monitor的所有权。
    
    5.reentrantlock?
    6.各种锁



