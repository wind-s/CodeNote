## 分布式篇

####1.分布式系统

####2.CAP理论

####3.BASE理论

####4.如何保证幂等

​	分布式锁，保证一个线程操作。
​    1.一个订单不允许被多次支付（包括并发状态下不允许被多个人同时支付）
​    下单前对订单状态（status字段）校验，对订单加上乐观锁（加上一个字段lock），只有加锁成功的人才能进行支付。
​    或者针对每个订单生成唯一支付日志，保证一个未支付的订单只允许被一个线程支付。
​		2.库存扣减，不允许超卖。
​    需要考虑场景，在c端展示层，读取缓存的方式，如果库存扣减了，消息异步更新缓存。
​    在对库存更改的时候，使用分布式锁，锁住某个产品id的库存，只允许一个线程去更改。

#### 5.raft算法和zk选主算法
​	6.1 raft算法
​    https://zhuanlan.zhihu.com/p/28560167
​    Raft 解决的问题很简单，就是让多个副本的日志数据达成一致。选举过半即能成为leader,然后和follower保持心跳，
​    过程大概是 candidate（候选人） 发起投票，follower 可以投同意票，也可以投反对票。过半的 follower 同意，则 candidate 当选为 leader。
​    显然，这样每一届选举，只能选出一个 leader。过期的leader说话无效。
​    拜占庭将军问题，m叛徒，n总人数， n>3m, 保证一致性。
​	6.2 zk选主算法
​    https://zhuanlan.zhihu.com/p/27335748

####6.如何保证分布式缓存的一致性

https://cloud.tencent.com/developer/article/1154683

先更新数据库，再删除缓存。（facebook都在用的方法）

删除缓存失败，通过canal中间件订阅mysql binlog，进行删除缓存，

若缓存删除失败，丢到消息队列进行充实即可。

![](./pic/分布式缓存一致性.jpeg)



#### 7.分布式session实现

Redis存储用户生成的sessionId或者存储保存sessionId的cookie

https://juejin.im/post/5dce3f83e51d4507f87d07a6

8.分布式锁的实现方式？

https://juejin.im/post/5bbb0d8df265da0abd3533a5

1.mysql分布式锁

​	1.1 lock()阻塞式的获取锁，意思就是不获取到锁誓不罢休.

​	1.2 tryLock()和tryLock(long timeout) 非阻塞获取锁，如果获取不到那么就会马上返回

​	1.3 锁超时，定时任务进行删除。

​	自己实现的方式，需要加上事务。

2.zookeeper

​	

3.redis







消息队列连环炮：

##### 1.为什么使用消息队列

​	 期望回答：业务场景，有什么技术挑战，带来什么好处？

​			解耦、异步、削峰

###### 解耦

​	会员业务，购买额外赠送活动优惠，如果没mq, 代码中的短期有效业务逻辑太多，活动下线后，还得屏蔽，导致项目堆积废代码，很麻烦，如果某个业务接口调用失败了，还得去进行重试，逻辑原来越复杂。引入mq，单独写逻辑即可，即使挂了也能简单重试处理。不需要消息，消费者取消消费即可。

异步：

​	提高响应速度

削峰：

​	防止系统被打死。

​	mysql 每秒也就能撑2000个请求，如果一下子5000个请求进来，那就被打死了。加入mq, 保证消费者消费符合mysql的条数，但是会有挤压。需要时间长一点就行消费完堆积消息，削峰。



使用消息队列的场景：1，需要解耦的项目。2，异步可以提升接口性能的项目。3，高峰期影响数据库存储的项目。 解耦：上游的系统不用管下游的系统，只用把数据发送到MQ上就可以了，下游的系统自己从MQ里拿数据 异步：A调用多个系统特别耗时。可以将数据发送到MQ，一个响应就结束了。后面异步地从MQ里获得数据，执行剩下的逻辑。 削峰：进来的请求不直接处理，而是发送给MQ，然后再从MQ里获得部分数据进行业务持久层的操作。高峰时间MQ中的数据，进来的多出去的少。出去的只要保证数据库不挂掉就好了。虽然会有大部分数据挤压在MQ，但当高峰期一过，进来（请求）的数据少，出去（处理）的数据多，很快就能处理完了	

##### 2.消息队列有什么优缺点？

​	1.系统可用性降低。mq一挂，系统就完蛋了。

​	2.系统复杂性高了。发送消息重复，消息丢失。

​	3.削峰，数据积压变大，内存满了咋办。

​	4.异步处理请求处理a b c d，如果某个异步一环d失败了，但是给用户返回正确，那就有问题了。

##### 3.kafka，activemq, rabbitmq,rocketmq有什么区别？适合场景

##### 4.消息队列如何保证高可用？

https://blog.csdn.net/u014801403/article/details/80312677

​	kafka、rabbitmq、rocketmq如何保证高可用的

​	rabbitmq 镜像集群模式，每个节点的数据都一样，高可用，但是不是分布式高可用，数据冗余。开启，配置一个镜像集群模式策略，创建queue使用该策略即可同步数据。

​	Kafka高可用

​	topic 均匀分配到不同机器，每个机器有副本数据一样的机器，有一个主节点，执行读写操作，如果挂了，系统会自动从从节点中选出一个主节点，保证高可用。

​	rocketmq

​	多个broker 从节点， 相互不通信，多个nameserver相互不通信，每个broker注册到多个broker上

​	配置主节点，不能自动选主，4.5以前，除非加入zookeeper, 需要手动配置，所以不好呀，转kafka吧，自动配置。



##### 5.消息队列里消费重复数据？

以上mq都有可能消息重发，保证你消息不丢失。保证消息不重复，是你自己的事情，你要解决。

kafka，消费者消费kafka数据，会记录offset，消费到哪里，需要定时去报告给kafka，如果这个时候消费者重启，消费者没有提交成功这次的offset，就让kafka把上次提交的offset后的数据进行再次推送过来，这就重复数据。



需要幂等性保障机制了。消费者消费之前，判断一下有没有被消费过。可用redis进行拦截一下。数据库的唯一键也行，会员业务用的是redis进行去重。



##### 6.消息队列丢失数据？



#### 7.消息队列积压几百万数据咋办？

​	消费者挂了，现在恢复了，那么如何快速消费掉数据，如果原来只有三台消费者，每秒处理1000条

​	新建一个topic, partion是原来的10倍， 把原来的消费者写到新的topic里去，然后部署30个消费者，进行新topic消费。等问题解决了，再进行恢复原消费者。



如果使用了rabbitmq，设置了过期时间，那就很坑，最后的建议就是，写个程序，从消息源头进行查找丢弃的消息，然后重新扔到消息队列中。



如果mq快撑爆了，那只能丢弃数据了，然后进行数据查出来进行补偿，下策了。



#####8.如何设计一个mq

1.数据分布，多个broker，多个partion分布式部署存储

2.数据丢失，需要落盘存储

3.高可用设计，主从同步，自动选主，避免一个机器挂了，能够选择一个机器出来顶上去

4.消息丢失，需要ack确认机制。

5.保证消息的顺序





##### 9.分布式缓存怎么用

高性能，高并发，会员项目活动缓存热点数据，商品套餐数据，不能每次去mysql查询。

1、高性能：用于多读少改的场景，然后优化读取的速度。 2、高并发：redis基于内存可以提供很高的读写性能从而支撑高并发。 存在哪些问题？缓存是内存中的，天然支持高并发，每秒支持4w/s都可以

 1、缓存穿透 2、缓存雪崩等等。

缓存与数据库双写不一致问题

缓存雪崩

缓存穿透

缓存并发竞争

##### 9.消息队列面试技巧

1.快速了解rabbitmq和kafka的原理入门。

2.如果不问，就把这些问题都包装一下说出来，什么消息队列，怎么保证高可用，消息不丢失，消息重复，消息顺序消费。



##### 10.redis线程模型，为什么单线程还能高效率

nio 异步模型，工作原理，socket网络通信相关关系。

#####11.redis和memcached区别？

1.redis比memcached数据结构更多，支持丰富的数据操作，更复杂的场景。

2.redis存储100k以下的数据性能更高，memcached在大雨100k 的数据性能更高。

3.memcached没有集群模式，需要客户端进行做分片存储的，redis的哨兵模式集群。高可用。





#####11.mysql的主从同步的延时问题怎么解决？

从库：读取binlog日志，写relay日志，应用日志变更到自己本地数据，是串行化的。所以从库同步数据会慢点。

sql线程单线程把relay日志单线程把数据同步到从数据库中，

如果主库每秒并发1000，从库会有几ms，

​								2000				几十ms

​								4000\6000\8000	几秒

如果主机宕机，从库数据没法读取到，可以开启半同步复制，semi-sync，保证有一台从库同步数据成功。从库拉到binlog日志到自己的relay日志即可。5.7版本以后，并行复制，每个库的数据一条sql线程去复制。效率会快一点。

1.主从复制的原理

2.主从延迟问题产生的原因

3.主从复制丢失数据问题，以及半同步复制的原理。

4.并行复制的原理，多库并发重放relay日志，缓解主从延迟问题。



精华：

线上处理主从同步延时问题，导致线上的bug，小型生产事故：

select 数据为空，那就是id为null, update where id=null失败，更新状态不对，所以就报障。

1.分库，把大主库分成多个小主库，这样就能降低延迟。

2.并行复制的意义不大，但是还得打开并行复制，有些效果。

**3.重写代码，是不是没必要，先插入，然后查询，再更新，这样有问题。可以是先插入，然后更新数据，都是写操作，直连主库，不会有同步问题。**

4.如果必须是要直接插入，然后立马查询到，再执行一些操作，那就使得查询也直连数据库，但是不推荐，丧失了读写分离的意义。

所以写代码要慎重。





##### 12.分库分表后全局id怎么生成？

##### 13.如何进行不停机的情况下，进行分库分表下？

双写，然后写个程序开始后台进行数据同步。

Sharding-jdbc、mycat





##### 14.分布式session怎么实现的？

Spring-session+redis 分布式session



##### 15.dubbo工作原理是什么，注册中心挂了还能继续通信吗？

​	工作原理：

​		第一层：service层，给服务提供者和消费者来实现的。

​		第二层：config层，配置层，主要是对dubbo进行各种配置的。

​		第三层：proxy层

​		

思考：

1.项目架构为什么要这样设计，思考过没？

2.引入技术有什么好处，和坏处，有什么坑？ 

3.调研同类型技术的优缺点，要调研呀，扬长避短？

4.mq技术快速入门，看看原理，应用，场景，特点。